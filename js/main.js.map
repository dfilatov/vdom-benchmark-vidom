{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","web/js/main.js","node_modules/browserify/node_modules/process/browser.js","node_modules/vdom-benchmark-base/lib/benchmark.js","node_modules/vdom-benchmark-base/lib/executor.js","node_modules/vdom-benchmark-base/lib/index.js","node_modules/vidom/lib/vidom.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var benchmark = require('vdom-benchmark-base');\nvar vidom = require('vidom');\nvar node = vidom.node;\n\nvar NAME = 'vidom';\nvar VERSION = '0.3.12';\n\nfunction renderTree(nodes) {\n  var children = [];\n  var i;\n  var n;\n\n  for (i = 0; i < nodes.length; i++) {\n    n = nodes[i];\n    if (n.children !== null) {\n      children.push(node('div').key(n.key).children(renderTree(n.children)));\n    } else {\n      children.push(node('span').key(n.key).children(n.key));\n    }\n  }\n\n  return children;\n}\n\nfunction BenchmarkImpl(container, a, b) {\n  this.container = container;\n  this.a = a;\n  this.b = b;\n}\n\nBenchmarkImpl.prototype.setUp = function() {\n};\n\nBenchmarkImpl.prototype.tearDown = function() {\n  vidom.unmountFromDomSync(this.container);\n};\n\nBenchmarkImpl.prototype.render = function() {\n  vidom.mountToDomSync(\n    this.container,\n    node('div').children(renderTree(this.a)));\n};\n\nBenchmarkImpl.prototype.update = function() {\n  vidom.mountToDomSync(\n    this.container,\n    node('div').children(renderTree(this.b)));\n};\n\ndocument.addEventListener('DOMContentLoaded', function(e) {\n  benchmark(NAME, VERSION, BenchmarkImpl);\n}, false);\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            currentQueue[queueIndex].run();\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","'use strict';\n\nvar Executor = require('./executor');\n\nfunction Benchmark() {\n  this.running = false;\n  this.impl = null;\n  this.tests = null;\n  this.reportCallback = null;\n  this.enableTests = false;\n\n  this.container = document.createElement('div');\n\n  this._runButton = document.getElementById('RunButton');\n  this._iterationsElement = document.getElementById('Iterations');\n  this._reportElement = document.createElement('pre');\n\n  document.body.appendChild(this.container);\n  document.body.appendChild(this._reportElement);\n\n  var self = this;\n\n  this._runButton.addEventListener('click', function(e) {\n    e.preventDefault();\n\n    if (!self.running) {\n      var iterations = parseInt(self._iterationsElement.value);\n      if (iterations <= 0) {\n        iterations = 10;\n      }\n\n      self.run(iterations);\n    }\n  }, false);\n\n  this.ready(true);\n}\n\nBenchmark.prototype.ready = function(v) {\n  if (v) {\n    this._runButton.disabled = '';\n  } else {\n    this._runButton.disabled = 'true';\n  }\n};\n\nBenchmark.prototype.run = function(iterations) {\n  var self = this;\n  this.running = true;\n  this.ready(false);\n\n  new Executor(self.impl, self.container, self.tests, 1, function() { // warmup\n    new Executor(self.impl, self.container, self.tests, iterations, function(samples) {\n      self._reportElement.textContent = JSON.stringify(samples, null, ' ');\n      self.running = false;\n      self.ready(true);\n      if (self.reportCallback != null) {\n        self.reportCallback(samples);\n      }\n    }, undefined, false).start();\n  }, undefined, this.enableTests).start();\n};\n\nmodule.exports = Benchmark;\n","'use strict';\n\nfunction render(nodes) {\n  var children = [];\n  var j;\n  var c;\n  var i;\n  var e;\n  var n;\n\n  for (i = 0; i < nodes.length; i++) {\n    n = nodes[i];\n    if (n.children !== null) {\n      e = document.createElement('div');\n      c = render(n.children);\n      for (j = 0; j < c.length; j++) {\n        e.appendChild(c[j]);\n      }\n      children.push(e);\n    } else {\n      e = document.createElement('span');\n      e.textContent = n.key.toString();\n      children.push(e);\n    }\n  }\n\n  return children;\n}\n\nfunction testInnerHtml(testName, nodes, container) {\n  var c = document.createElement('div');\n  var e = document.createElement('div');\n  var children = render(nodes);\n  for (var i = 0; i < children.length; i++) {\n    e.appendChild(children[i]);\n  }\n  c.appendChild(e);\n  if (c.innerHTML !== container.innerHTML) {\n    console.log('error in test: ' + testName);\n    console.log('container.innerHTML:');\n    console.log(container.innerHTML);\n    console.log('should be:');\n    console.log(c.innerHTML);\n  }\n}\n\n\nfunction Executor(impl, container, tests, iterations, cb, iterCb, enableTests) {\n  if (iterCb === void 0) iterCb = null;\n\n  this.impl = impl;\n  this.container = container;\n  this.tests = tests;\n  this.iterations = iterations;\n  this.cb = cb;\n  this.iterCb = iterCb;\n  this.enableTests = enableTests;\n\n  this._currentTest = 0;\n  this._currentIter = 0;\n  this._renderSamples = [];\n  this._updateSamples = [];\n  this._result = [];\n\n  this._tasksCount = tests.length * iterations;\n\n  this._iter = this.iter.bind(this);\n}\n\nExecutor.prototype.start = function() {\n  this._iter();\n};\n\nExecutor.prototype.finished = function() {\n  this.cb(this._result);\n};\n\nExecutor.prototype.progress = function() {\n  if (this._currentTest === 0 && this._currentIter === 0) {\n    return 0;\n  }\n\n  var tests = this.tests;\n  return (this._currentTest * tests.length + this._currentIter) / (tests.length * this.iterataions);\n};\n\nExecutor.prototype.iter = function() {\n  if (this.iterCb != null) {\n    this.iterCb(this);\n  }\n\n  var tests = this.tests;\n\n  if (this._currentTest < tests.length) {\n    var test = tests[this._currentTest];\n\n    if (this._currentIter < this.iterations) {\n      var e, t;\n      var renderTime, updateTime;\n\n      e = new this.impl(this.container, test.data.a, test.data.b);\n      e.setUp();\n\n      t = window.performance.now();\n      e.render();\n      renderTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'render()', test.data.a, this.container);\n      }\n\n      t = window.performance.now();\n      e.update();\n      updateTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'update()', test.data.b, this.container);\n      }\n\n      e.tearDown();\n\n      this._renderSamples.push(renderTime);\n      this._updateSamples.push(updateTime);\n\n      this._currentIter++;\n    } else {\n      this._result.push({\n        name: test.name + ' ' + 'render()',\n        data: this._renderSamples.slice(0)\n      });\n\n      this._result.push({\n        name: test.name + ' ' + 'update()',\n        data: this._updateSamples.slice(0)\n      });\n\n      this._currentTest++;\n\n      this._currentIter = 0;\n      this._renderSamples = [];\n      this._updateSamples = [];\n    }\n\n    setTimeout(this._iter, 0);\n  } else {\n    this.finished();\n  }\n};\n\nmodule.exports = Executor;\n","'use strict';\n\nvar Benchmark = require('./benchmark');\nvar benchmark = new Benchmark();\n\nfunction initFromScript(scriptUrl, impl) {\n  var e = document.createElement('script');\n  e.src = scriptUrl;\n\n  e.onload = function() {\n    benchmark.tests = window.generateBenchmarkData().units;\n    benchmark.ready(true);\n  };\n\n  document.head.appendChild(e);\n}\n\nfunction initFromParentWindow(parent, name, version, id) {\n  window.addEventListener('message', function(e) {\n    var data = e.data;\n    var type = data.type;\n\n    if (type === 'tests') {\n      benchmark.tests = data.data;\n      benchmark.reportCallback = function(samples) {\n        parent.postMessage({\n          type: 'report',\n          data: {\n            name: name,\n            version: version,\n            samples: samples\n          },\n          id: id\n        }, '*');\n      };\n      benchmark.ready(true);\n\n      parent.postMessage({\n        type: 'ready',\n        data: null,\n        id: id\n      }, '*');\n    } else if (type === 'run') {\n      benchmark.run(data.data.iterations);\n    }\n  }, false);\n\n  parent.postMessage({\n    type: 'init',\n    data: null,\n    id: id\n  }, '*');\n}\n\nfunction init(name, version, impl) {\n  // Parse Query String.\n  var qs = (function(a) {\n    if (a == \"\") return {};\n    var b = {};\n    for (var i = 0; i < a.length; ++i) {\n      var p=a[i].split('=', 2);\n      if (p.length == 1) {\n        b[p[0]] = \"\";\n      } else {\n        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n      }\n    }\n    return b;\n  })(window.location.search.substr(1).split('&'));\n\n  if (qs['name'] !== void 0) {\n    name = qs['name'];\n  }\n\n  if (qs['version'] !== void 0) {\n    version = qs['version'];\n  }\n\n  var type = qs['type'];\n\n  if (qs['test'] !== void 0) {\n    benchmark.enableTests = true;\n    console.log('tests enabled');\n  }\n\n  var id;\n  if (type === 'iframe') {\n    id = qs['id'];\n    if (id === void 0) id = null;\n    initFromParentWindow(window.parent, name, version, id);\n  } else if (type === 'window') {\n    if (window.opener != null) {\n      id = qs['id'];\n      if (id === void 0) id = null;\n      initFromParentWindow(window.opener, name, version, id);\n    } else {\n      console.log('Failed to initialize: opener window is NULL');\n    }\n  } else {\n    var testsUrl = qs['data']; // url to the script generating test data\n    if (testsUrl !== void 0) {\n      initFromScript(testsUrl);\n    } else {\n      console.log('Failed to initialize: cannot load tests data');\n    }\n  }\n\n  benchmark.impl = impl;\n}\n\n// performance.now() polyfill\n// https://gist.github.com/paulirish/5438650\n// prepare base perf object\nif (typeof window.performance === 'undefined') {\n  window.performance = {};\n}\nif (!window.performance.now){\n  var nowOffset = Date.now();\n  if (performance.timing && performance.timing.navigationStart) {\n    nowOffset = performance.timing.navigationStart;\n  }\n  window.performance.now = function now(){\n    return Date.now() - nowOffset;\n  };\n}\n\nmodule.exports = init;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar escapeAttr = (function (str) {\n    return (str + '').replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n});\n\nvar isInArray = (function (arr, item) {\n    var len = arr.length;\n    var i = 0;\n\n    while (i < len) {\n        if (arr[i++] == item) {\n            return true;\n        }\n    }\n\n    return false;\n});\n\nvar DASHERIZE_RE = /([^A-Z]+)([A-Z])/g;\n\nvar dasherize = (function (str) {\n  return str.replace(DASHERIZE_RE, '$1-$2').toLowerCase();\n});\n\nvar noOp = (function () {});\n\nvar globalConsole = typeof console == 'undefined' ? null : console;\nvar consoleWrapper = {};\nvar PREFIXES = {\n    log: '',\n    info: '',\n    warn: 'Warning!',\n    error: 'Error!'\n};\n['log', 'info', 'warn', 'error'].forEach(function (name) {\n    consoleWrapper[name] = globalConsole ? globalConsole[name] ? function (arg1, arg2, arg3, arg4, arg5) {\n        // IE9: console methods aren't functions\n        var arg0 = PREFIXES[name];\n        switch (arguments.length) {\n            case 1:\n                globalConsole[name](arg0, arg1);\n                break;\n\n            case 2:\n                globalConsole[name](arg0, arg1, arg2);\n                break;\n\n            case 3:\n                globalConsole[name](arg0, arg1, arg2, arg3);\n                break;\n\n            case 4:\n                globalConsole[name](arg0, arg1, arg2, arg3, arg4);\n                break;\n\n            case 5:\n                globalConsole[name](arg0, arg1, arg2, arg3, arg4, arg5);\n                break;\n        }\n    } : function () {\n        globalConsole.log.apply(globalConsole, arguments);\n    } : noOp;\n});\n\nvar IS_DEBUG = typeof process === 'undefined' || \"development\" !== 'production';\n\nfunction setAttr(node, name, val) {\n    if (name === 'type' && node.tagName === 'INPUT') {\n        var value = node.value; // value will be lost in IE if type is changed\n        node.setAttribute(name, '' + val);\n        node.value = value;\n    } else {\n        node.setAttribute(ATTR_NAMES[name] || name, '' + val);\n    }\n}\n\nfunction setBooleanAttr(node, name, val) {\n    if (val) {\n        setAttr(node, name, val);\n    } else {\n        removeAttr$1(node, name);\n    }\n}\n\nfunction setProp(node, name, val) {\n    node[name] = val;\n}\n\nfunction setObjProp(node, name, val) {\n    if (IS_DEBUG) {\n        var typeOfVal = typeof val;\n        if (typeOfVal !== 'object') {\n            consoleWrapper.error('\"' + name + '\" attribute expects an object as a value, not a ' + typeOfVal);\n            return;\n        }\n    }\n\n    var prop = node[name];\n    for (var i in val) {\n        prop[i] = val[i] == null ? '' : val[i];\n    }\n}\n\nfunction setPropWithCheck(node, name, val) {\n    if (name === 'value' && node.tagName === 'SELECT') {\n        setSelectValue(node, val);\n    } else {\n        node[name] !== val && (node[name] = val);\n    }\n}\n\nfunction removeAttr$1(node, name) {\n    node.removeAttribute(ATTR_NAMES[name] || name);\n}\n\nfunction removeProp(node, name) {\n    if (name === 'style') {\n        node[name].cssText = '';\n    } else if (name === 'value' && node.tagName === 'SELECT') {\n        removeSelectValue(node);\n    } else {\n        node[name] = getDefaultPropVal(node.tagName, name);\n    }\n}\n\nfunction setSelectValue(node, value) {\n    var isMultiple = Array.isArray(value),\n        options = node.options,\n        len = options.length;\n\n    var i = 0,\n        optionNode = void 0;\n\n    while (i < len) {\n        optionNode = options[i++];\n        optionNode.selected = value != null && (isMultiple ? isInArray(value, optionNode.value) : optionNode.value == value);\n    }\n}\n\nfunction removeSelectValue(node) {\n    var options = node.options,\n        len = options.length;\n\n    var i = 0;\n\n    while (i < len) {\n        options[i++].selected = false;\n    }\n}\n\nfunction attrToString(name, value) {\n    return (ATTR_NAMES[name] || name) + '=\"' + escapeAttr(value) + '\"';\n}\n\nfunction booleanAttrToString(name, value) {\n    return value ? name : '';\n}\n\nfunction stylePropToString(name, value) {\n    var styles = '';\n\n    for (var i in value) {\n        value[i] != null && (styles += dasherize(i) + ':' + value[i] + ';');\n    }\n\n    return styles ? name + '=\"' + styles + '\"' : styles;\n}\n\nvar defaultPropVals = {};\nfunction getDefaultPropVal(tag, attrName) {\n    var tagAttrs = defaultPropVals[tag] || (defaultPropVals[tag] = {});\n    return attrName in tagAttrs ? tagAttrs[attrName] : tagAttrs[attrName] = document.createElement(tag)[attrName];\n}\n\nvar ATTR_NAMES = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv',\n    autoCapitalize: 'autocapitalize',\n    autoComplete: 'autocomplete',\n    autoCorrect: 'autocorrect',\n    autoFocus: 'autofocus',\n    autoPlay: 'autoplay',\n    encType: 'encoding',\n    hrefLang: 'hreflang',\n    radioGroup: 'radiogroup',\n    spellCheck: 'spellcheck',\n    srcDoc: 'srcdoc',\n    srcSet: 'srcset',\n    tabIndex: 'tabindex'\n};\nvar DEFAULT_ATTR_CFG = {\n    set: setAttr,\n    remove: removeAttr$1,\n    toString: attrToString\n};\nvar BOOLEAN_ATTR_CFG = {\n    set: setBooleanAttr,\n    remove: removeAttr$1,\n    toString: booleanAttrToString\n};\nvar DEFAULT_PROP_CFG = {\n    set: setProp,\n    remove: removeProp,\n    toString: attrToString\n};\nvar BOOLEAN_PROP_CFG = {\n    set: setProp,\n    remove: removeProp,\n    toString: booleanAttrToString\n};\nvar attrsCfg = {\n    checked: BOOLEAN_PROP_CFG,\n    controls: DEFAULT_PROP_CFG,\n    disabled: BOOLEAN_ATTR_CFG,\n    id: DEFAULT_PROP_CFG,\n    ismap: BOOLEAN_ATTR_CFG,\n    loop: DEFAULT_PROP_CFG,\n    multiple: BOOLEAN_PROP_CFG,\n    muted: DEFAULT_PROP_CFG,\n    open: BOOLEAN_ATTR_CFG,\n    readOnly: BOOLEAN_PROP_CFG,\n    selected: BOOLEAN_PROP_CFG,\n    srcDoc: DEFAULT_PROP_CFG,\n    style: {\n        set: setObjProp,\n        remove: removeProp,\n        toString: stylePropToString\n    },\n    value: {\n        set: setPropWithCheck,\n        remove: removeProp,\n        toString: attrToString\n    }\n};\nfunction domAttrs (attrName) {\n    return attrsCfg[attrName] || DEFAULT_ATTR_CFG;\n}\n\nfunction append(parent, child) {\n    if (Array.isArray(parent)) {\n        insertBefore(child, parent[1]);\n    } else if (Array.isArray(child)) {\n        var currentChild = child[0],\n            nextChild = void 0;\n        var lastChild = child[1];\n\n        while (currentChild !== lastChild) {\n            nextChild = currentChild.nextSibling;\n            parent.appendChild(currentChild);\n            currentChild = nextChild;\n        }\n\n        parent.appendChild(lastChild);\n    } else {\n        parent.appendChild(child);\n    }\n}\n\nfunction remove(child) {\n    if (Array.isArray(child)) {\n        var currentChild = child[0],\n            nextChild = void 0;\n        var lastChild = child[1],\n            parent = lastChild.parentNode;\n\n        while (currentChild !== lastChild) {\n            nextChild = currentChild.nextSibling;\n            parent.removeChild(currentChild);\n            currentChild = nextChild;\n        }\n\n        parent.removeChild(lastChild);\n    } else {\n        child.parentNode.removeChild(child);\n    }\n}\n\nfunction insertBefore(child, beforeChild) {\n    Array.isArray(beforeChild) && (beforeChild = beforeChild[0]);\n\n    if (Array.isArray(child)) {\n        var currentChild = child[0],\n            nextChild = void 0;\n        var lastChild = child[1],\n            parent = lastChild.parentNode;\n\n        while (currentChild !== lastChild) {\n            nextChild = currentChild.nextSibling;\n            parent.insertBefore(currentChild, beforeChild);\n            currentChild = nextChild;\n        }\n\n        parent.insertBefore(lastChild, beforeChild);\n    } else {\n        beforeChild.parentNode.insertBefore(child, beforeChild);\n    }\n}\n\nfunction move(child, toChild, after) {\n    if (after) {\n        Array.isArray(toChild) && (toChild = toChild[1]);\n        var nextSibling = toChild.nextSibling;\n\n        nextSibling ? insertBefore(child, nextSibling) : append(toChild.parentNode, child);\n    } else {\n        insertBefore(child, toChild);\n    }\n}\n\nfunction replace$1(old, replacement) {\n    if (Array.isArray(old)) {\n        insertBefore(replacement, old);\n        remove(old);\n    } else {\n        old.parentNode.replaceChild(replacement, old);\n    }\n}\n\nfunction removeChildren$1(from) {\n    if (Array.isArray(from)) {\n        var currentChild = from[0].nextSibling,\n            nextChild = void 0;\n        var lastChild = from[1],\n            parent = lastChild.parentNode;\n\n        while (currentChild !== lastChild) {\n            nextChild = currentChild.nextSibling;\n            parent.removeChild(currentChild);\n            currentChild = nextChild;\n        }\n    } else {\n        from.innerHTML = '';\n    }\n}\n\nvar domOps = {\n    append: append,\n    remove: remove,\n    insertBefore: insertBefore,\n    move: move,\n    replace: replace$1,\n    removeChildren: removeChildren$1\n};\n\nvar DEFAULT_NS_URI = 'http://www.w3.org/1999/xhtml';\n\nfunction getNs(domNode) {\n    return Array.isArray(domNode) ? getParentNs(domNode) : domNode.namespaceURI === DEFAULT_NS_URI ? null : domNode.namespaceURI;\n}\n\nfunction getParentNs(domNode) {\n    return getNs((Array.isArray(domNode) ? domNode[domNode.length - 1] : domNode).parentNode);\n}\n\nfunction isEventSupported(type) {\n    var eventProp = 'on' + type;\n\n    if (eventProp in document) {\n        return true;\n    }\n\n    var domNode = document.createElement('div');\n\n    domNode.setAttribute(eventProp, 'return;');\n    if (typeof domNode[eventProp] === 'function') {\n        return true;\n    }\n\n    return type === 'wheel' && document.implementation && document.implementation.hasFeature && document.implementation.hasFeature('', '') !== true && document.implementation.hasFeature('Events.wheel', '3.0');\n}\n\nfunction SyntheticEvent(type, nativeEvent) {\n    this.type = type;\n    this.target = nativeEvent.target;\n    this.nativeEvent = nativeEvent;\n\n    this._isPropagationStopped = false;\n    this._isDefaultPrevented = false;\n    this._isSeized = false;\n}\n\nSyntheticEvent.prototype = {\n    stopPropagation: function () {\n        this._isPropagationStopped = true;\n\n        var nativeEvent = this.nativeEvent;\n        nativeEvent.stopPropagation ? nativeEvent.stopPropagation() : nativeEvent.cancelBubble = true;\n    },\n    isPropagationStopped: function () {\n        return this._isPropagationStopped;\n    },\n    preventDefault: function () {\n        this._isDefaultPrevented = true;\n\n        var nativeEvent = this.nativeEvent;\n        nativeEvent.preventDefault ? nativeEvent.preventDefault() : nativeEvent.returnValue = false;\n    },\n    isDefaultPrevented: function () {\n        return this._isDefaultPrevented;\n    },\n    persist: function () {\n        this._isPersisted = true;\n    }\n};\n\nvar eventsPool = {};\n\nfunction createSyntheticEvent(type, nativeEvent) {\n    var pooledEvent = eventsPool[type];\n\n    if (pooledEvent && !pooledEvent._isPersisted) {\n        pooledEvent.target = nativeEvent.target;\n        pooledEvent.nativeEvent = nativeEvent;\n        pooledEvent._isPropagationStopped = false;\n        pooledEvent._isDefaultPrevented = false;\n\n        return pooledEvent;\n    }\n\n    return eventsPool[type] = new SyntheticEvent(type, nativeEvent);\n}\n\nvar ID_PROP = '__vidom__id__';\nvar counter = 1;\n\nfunction getDomNodeId(node, onlyGet) {\n    return node[ID_PROP] || (onlyGet ? null : node[ID_PROP] = counter++);\n}\n\nvar BUBBLEABLE_NATIVE_EVENTS = ['blur', 'change', 'click', 'contextmenu', 'copy', 'cut', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragleave', 'dragover', 'dragstart', 'drop', 'focus', 'input', 'keydown', 'keypress', 'keyup', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'paste', 'submit', 'touchcancel', 'touchend', 'touchmove', 'touchstart', 'wheel'];\nvar NON_BUBBLEABLE_NATIVE_EVENTS = ['canplay', 'canplaythrough', 'complete', 'durationchange', 'emptied', 'ended', 'error', 'load', 'loadeddata', 'loadedmetadata', 'loadstart', 'mouseenter', 'mouseleave', 'pause', 'play', 'playing', 'progress', 'ratechange', 'scroll', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting'];\nvar listenersStorage = {};\nvar eventsCfg = {};\nfunction globalEventListener(e, type) {\n    type || (type = e.type);\n\n    var cfg = eventsCfg[type];\n\n    var target = e.target,\n        listenersCount = cfg.listenersCounter,\n        listeners = void 0,\n        listener = void 0,\n        listenersToInvoke = void 0,\n        domNodeId = void 0;\n\n    while (listenersCount > 0 && target && target !== document) {\n        if (domNodeId = getDomNodeId(target, true)) {\n            listeners = listenersStorage[domNodeId];\n            if (listeners && (listener = listeners[type])) {\n                if (listenersToInvoke) {\n                    listenersToInvoke.push(listener);\n                } else {\n                    listenersToInvoke = [listener];\n                }\n                --listenersCount;\n            }\n        }\n\n        target = target.parentNode;\n    }\n\n    if (listenersToInvoke) {\n        var event = createSyntheticEvent(type, e),\n            len = listenersToInvoke.length;\n\n        var i = 0;\n\n        while (i < len) {\n            listenersToInvoke[i++](event);\n            if (event.isPropagationStopped()) {\n                break;\n            }\n        }\n    }\n}\n\nfunction eventListener(e) {\n    listenersStorage[getDomNodeId(e.target)][e.type](createSyntheticEvent(e.type, e));\n}\n\nif (typeof document !== 'undefined') {\n    (function () {\n        var focusEvents = {\n            focus: 'focusin',\n            blur: 'focusout'\n        };\n\n        var i = 0,\n            type = void 0;\n\n        while (i < BUBBLEABLE_NATIVE_EVENTS.length) {\n            type = BUBBLEABLE_NATIVE_EVENTS[i++];\n            eventsCfg[type] = {\n                type: type,\n                bubbles: true,\n                listenersCounter: 0,\n                set: false,\n                setup: focusEvents[type] ? isEventSupported(focusEvents[type]) ? function () {\n                    var type = this.type;\n                    document.addEventListener(focusEvents[type], function (e) {\n                        globalEventListener(e, type);\n                    });\n                } : function () {\n                    document.addEventListener(this.type, globalEventListener, true);\n                } : null\n            };\n        }\n\n        i = 0;\n        while (i < NON_BUBBLEABLE_NATIVE_EVENTS.length) {\n            eventsCfg[NON_BUBBLEABLE_NATIVE_EVENTS[i++]] = {\n                type: type,\n                bubbles: false,\n                set: false\n            };\n        }\n    })();\n}\n\nfunction addListener(domNode, type, listener) {\n    var cfg = eventsCfg[type];\n    if (cfg) {\n        if (!cfg.set) {\n            cfg.setup ? cfg.setup() : cfg.bubbles && document.addEventListener(type, globalEventListener, false);\n            cfg.set = true;\n        }\n\n        var domNodeId = getDomNodeId(domNode),\n            listeners = listenersStorage[domNodeId] || (listenersStorage[domNodeId] = {});\n\n        if (!listeners[type]) {\n            cfg.bubbles ? ++cfg.listenersCounter : domNode.addEventListener(type, eventListener, false);\n        }\n\n        listeners[type] = listener;\n    }\n}\n\nfunction removeListener(domNode, type) {\n    var domNodeId = getDomNodeId(domNode, true);\n\n    if (domNodeId) {\n        var listeners = listenersStorage[domNodeId];\n\n        if (listeners && listeners[type]) {\n            listeners[type] = null;\n\n            var cfg = eventsCfg[type];\n\n            if (cfg) {\n                cfg.bubbles ? --cfg.listenersCounter : domNode.removeEventListener(type, eventListener);\n            }\n        }\n    }\n}\n\nfunction removeListeners(domNode) {\n    var domNodeId = getDomNodeId(domNode, true);\n\n    if (domNodeId) {\n        var listeners = listenersStorage[domNodeId];\n\n        if (listeners) {\n            delete listenersStorage[domNodeId];\n            for (var _type in listeners) {\n                removeListener(domNode, _type);\n            }\n        }\n    }\n}\n\nvar ATTRS_TO_EVENTS = {\n    onBlur: 'blur',\n    onCanPlay: 'canplay',\n    onCanPlayThrough: 'canplaythrough',\n    onChange: 'change',\n    onClick: 'click',\n    onComplete: 'complete',\n    onContextMenu: 'contextmenu',\n    onCopy: 'copy',\n    onCut: 'cut',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragEnter: 'dragenter',\n    onDragLeave: 'dragleave',\n    onDragOver: 'dragover',\n    onDragStart: 'dragstart',\n    onDrop: 'drop',\n    onDurationChange: 'durationchange',\n    onEmptied: 'emptied',\n    onEnded: 'ended',\n    onError: 'error',\n    onFocus: 'focus',\n    onInput: 'input',\n    onKeyDown: 'keydown',\n    onKeyPress: 'keypress',\n    onKeyUp: 'keyup',\n    onLoad: 'load',\n    onLoadedData: 'loadeddata',\n    onLoadedMetadata: 'loadedmetadata',\n    onLoadStart: 'loadstart',\n    onMouseDown: 'mousedown',\n    onMouseEnter: 'mouseenter',\n    onMouseLeave: 'mouseleave',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onPaste: 'paste',\n    onPause: 'pause',\n    onPlay: 'play',\n    onPlaying: 'playing',\n    onProgress: 'progress',\n    onRateChange: 'ratechange',\n    onScroll: 'scroll',\n    onSeeked: 'seeked',\n    onSeeking: 'seeking',\n    onStalled: 'stalled',\n    onSubmit: 'submit',\n    onSuspend: 'suspend',\n    onTimeUpdate: 'timeupdate',\n    onTouchCancel: 'touchcancel',\n    onTouchEnd: 'touchend',\n    onTouchMove: 'touchmove',\n    onTouchStart: 'touchstart',\n    onVolumeChange: 'volumechange',\n    onWaiting: 'waiting',\n    onWheel: 'wheel'\n};\n\nfunction appendChild(parentNode, childNode) {\n    var parentDomNode = parentNode.getDomNode();\n\n    domOps.append(parentDomNode, childNode.renderToDom(getNs(parentDomNode)));\n    childNode.mount();\n}\n\nfunction insertChild(childNode, beforeChildNode) {\n    var beforeChildDomNode = beforeChildNode.getDomNode();\n\n    domOps.insertBefore(childNode.renderToDom(getParentNs(beforeChildDomNode)), beforeChildDomNode);\n    childNode.mount();\n}\n\nfunction removeChild(childNode) {\n    var childDomNode = childNode.getDomNode();\n\n    childNode.unmount();\n    domOps.remove(childDomNode);\n}\n\nfunction moveChild(childNode, toChildNode, after) {\n    var activeDomNode = document.activeElement;\n\n    domOps.move(childNode.getDomNode(), toChildNode.getDomNode(), after);\n\n    if (document.activeElement !== activeDomNode) {\n        activeDomNode.focus();\n    }\n}\n\nfunction removeChildren(parentNode) {\n    var parentDomNode = parentNode.getDomNode(),\n        childNodes = parentNode._children,\n        len = childNodes.length;\n\n    var j = 0;\n\n    while (j < len) {\n        childNodes[j++].unmount();\n    }\n\n    domOps.removeChildren(parentDomNode);\n}\n\nfunction replace(oldNode, newNode) {\n    var oldDomNode = oldNode.getDomNode();\n\n    oldNode.unmount();\n    domOps.replace(oldDomNode, newNode.renderToDom(getParentNs(oldDomNode)));\n    newNode.mount();\n}\n\nfunction updateAttr(node, attrName, attrVal) {\n    var domNode = node.getDomNode();\n\n    ATTRS_TO_EVENTS[attrName] ? addListener(domNode, ATTRS_TO_EVENTS[attrName], attrVal) : domAttrs(attrName).set(domNode, attrName, attrVal);\n}\n\nfunction removeAttr(node, attrName) {\n    var domNode = node.getDomNode();\n\n    ATTRS_TO_EVENTS[attrName] ? removeListener(domNode, ATTRS_TO_EVENTS[attrName]) : domAttrs(attrName).remove(domNode, attrName);\n}\n\nfunction updateText(node, text, escape) {\n    var domNode = node.getDomNode();\n\n    if (escape) {\n        var firstChild = domNode.firstChild;\n\n        firstChild ? firstChild.nodeValue = text : domNode.textContent = text;\n    } else {\n        domNode.innerHTML = text;\n    }\n}\n\nfunction removeText(parentNode) {\n    parentNode.getDomNode().innerHTML = '';\n}\n\nvar patchOps = {\n    appendChild: appendChild,\n    insertChild: insertChild,\n    removeChild: removeChild,\n    moveChild: moveChild,\n    removeChildren: removeChildren,\n    replace: replace,\n    updateAttr: updateAttr,\n    removeAttr: removeAttr,\n    updateText: updateText,\n    removeText: removeText\n};\n\nfunction checkReuse(node, name) {\n    if (node.getDomNode()) {\n        console.error(\"You're trying to reuse the same node \\\"\" + name + \"\\\" more than once.\");\n    }\n}\n\nfunction checkChildren(children) {\n    var keys = {},\n        len = children.length;\n\n    var i = 0,\n        child = void 0;\n\n    while (i < len) {\n        child = children[i++];\n\n        if (typeof child !== 'object') {\n            consoleWrapper.error('You mustn\\'t use simple child in case of multiple children.');\n        } else if (child._key != null) {\n            if (child._key in keys) {\n                consoleWrapper.error('Childrens\\' keys must be unique across the children. Found duplicate of \"' + child._key + '\" key.');\n            } else {\n                keys[child._key] = true;\n            }\n        }\n    }\n}\n\nfunction patchChildren(nodeA, nodeB) {\n    var childrenA = nodeA._children,\n        childrenB = nodeB._children,\n        childrenALen = childrenA.length,\n        childrenBLen = childrenB.length;\n\n    if (childrenALen === 1 && childrenBLen === 1) {\n        childrenA[0].patch(childrenB[0]);\n        return;\n    }\n\n    var leftIdxA = 0,\n        rightIdxA = childrenALen - 1,\n        leftChildA = childrenA[leftIdxA],\n        leftChildAKey = leftChildA._key,\n        rightChildA = childrenA[rightIdxA],\n        rightChildAKey = rightChildA._key,\n        leftIdxB = 0,\n        rightIdxB = childrenBLen - 1,\n        leftChildB = childrenB[leftIdxB],\n        leftChildBKey = leftChildB._key,\n        rightChildB = childrenB[rightIdxB],\n        rightChildBKey = rightChildB._key,\n        updateLeftIdxA = false,\n        updateRightIdxA = false,\n        updateLeftIdxB = false,\n        updateRightIdxB = false,\n        childrenAIndicesToSkip = {},\n        childrenAKeys = void 0,\n        foundAChildIdx = void 0,\n        foundAChild = void 0;\n\n    while (leftIdxA <= rightIdxA && leftIdxB <= rightIdxB) {\n        if (childrenAIndicesToSkip[leftIdxA]) {\n            updateLeftIdxA = true;\n        } else if (childrenAIndicesToSkip[rightIdxA]) {\n            updateRightIdxA = true;\n        } else if (leftChildAKey === leftChildBKey) {\n            leftChildA.patch(leftChildB);\n            updateLeftIdxA = true;\n            updateLeftIdxB = true;\n        } else if (rightChildAKey === rightChildBKey) {\n            rightChildA.patch(rightChildB);\n            updateRightIdxA = true;\n            updateRightIdxB = true;\n        } else if (leftChildAKey != null && leftChildAKey === rightChildBKey) {\n            patchOps.moveChild(leftChildA, rightChildA, true);\n            leftChildA.patch(rightChildB);\n            updateLeftIdxA = true;\n            updateRightIdxB = true;\n        } else if (rightChildAKey != null && rightChildAKey === leftChildBKey) {\n            patchOps.moveChild(rightChildA, leftChildA, false);\n            rightChildA.patch(leftChildB);\n            updateRightIdxA = true;\n            updateLeftIdxB = true;\n        } else if (leftChildAKey != null && leftChildBKey == null) {\n            patchOps.insertChild(leftChildB, leftChildA);\n            updateLeftIdxB = true;\n        } else if (leftChildAKey == null && leftChildBKey != null) {\n            patchOps.removeChild(leftChildA);\n            updateLeftIdxA = true;\n        } else {\n            childrenAKeys || (childrenAKeys = buildKeys(childrenA, leftIdxA, rightIdxA));\n            if ((foundAChildIdx = childrenAKeys[leftChildBKey]) == null) {\n                patchOps.insertChild(leftChildB, leftChildA);\n            } else {\n                foundAChild = childrenA[foundAChildIdx];\n                childrenAIndicesToSkip[foundAChildIdx] = true;\n                patchOps.moveChild(foundAChild, leftChildA, false);\n                foundAChild.patch(leftChildB);\n            }\n            updateLeftIdxB = true;\n        }\n\n        if (updateLeftIdxA) {\n            updateLeftIdxA = false;\n            if (++leftIdxA <= rightIdxA) {\n                leftChildA = childrenA[leftIdxA];\n                leftChildAKey = leftChildA._key;\n            }\n        }\n\n        if (updateRightIdxA) {\n            updateRightIdxA = false;\n            if (--rightIdxA >= leftIdxA) {\n                rightChildA = childrenA[rightIdxA];\n                rightChildAKey = rightChildA._key;\n            }\n        }\n\n        if (updateLeftIdxB) {\n            updateLeftIdxB = false;\n            if (++leftIdxB <= rightIdxB) {\n                leftChildB = childrenB[leftIdxB];\n                leftChildBKey = leftChildB._key;\n            }\n        }\n\n        if (updateRightIdxB) {\n            updateRightIdxB = false;\n            if (--rightIdxB >= leftIdxB) {\n                rightChildB = childrenB[rightIdxB];\n                rightChildBKey = rightChildB._key;\n            }\n        }\n    }\n\n    while (leftIdxA <= rightIdxA) {\n        if (!childrenAIndicesToSkip[leftIdxA]) {\n            patchOps.removeChild(childrenA[leftIdxA]);\n        }\n        ++leftIdxA;\n    }\n\n    while (leftIdxB <= rightIdxB) {\n        rightIdxB < childrenBLen - 1 ? patchOps.insertChild(childrenB[leftIdxB], childrenB[rightIdxB + 1]) : patchOps.appendChild(nodeB, childrenB[leftIdxB]);\n        ++leftIdxB;\n    }\n};\n\nfunction buildKeys(children, idxFrom, idxTo) {\n    var res = {},\n        child = void 0;\n\n    while (idxFrom < idxTo) {\n        child = children[idxFrom];\n        child._key != null && (res[child._key] = idxFrom);\n        ++idxFrom;\n    }\n\n    return res;\n}\n\nvar escapeHtml = (function (str) {\n    return (str + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n});\n\nvar emptyObj = {};\n\nvar ua = typeof navigator === 'undefined' ? '' : navigator.userAgent;\n\nvar isTrident = ua.indexOf('Trident') > -1;\nvar isEdge = ua.indexOf('Edge') > -1;\n\nvar elementProtos = {};\n\nfunction createElement(tag, ns) {\n    var baseElement = void 0;\n\n    if (ns) {\n        var key = ns + ':' + tag;\n\n        baseElement = elementProtos[key] || (elementProtos[key] = document.createElementNS(ns, tag));\n    } else {\n        baseElement = elementProtos[tag] || (elementProtos[tag] = tag === '!' ? document.createComment('') : document.createElement(tag));\n    }\n\n    return baseElement.cloneNode();\n}\n\nvar TOP_LEVEL_NS_TAGS = {\n    'http://www.w3.org/2000/svg': 'svg',\n    'http://www.w3.org/1998/Math/MathML': 'math'\n};\n\nvar helperDomNode = void 0;\n\nfunction createElementByHtml(html, tag, ns) {\n    helperDomNode || (helperDomNode = document.createElement('div'));\n\n    if (!ns || !TOP_LEVEL_NS_TAGS[ns] || TOP_LEVEL_NS_TAGS[ns] === tag) {\n        helperDomNode.innerHTML = html;\n        return helperDomNode.removeChild(helperDomNode.firstChild);\n    }\n\n    var topLevelTag = TOP_LEVEL_NS_TAGS[ns];\n    helperDomNode.innerHTML = '<' + topLevelTag + ' xmlns=\"' + ns + '\">' + html + '</' + topLevelTag + '>';\n    return helperDomNode.removeChild(helperDomNode.firstChild).firstChild;\n}\n\nvar NODE_TYPE_TOP = 1;\nvar NODE_TYPE_TAG = 2;\nvar NODE_TYPE_FRAGMENT = 3;\nvar NODE_TYPE_COMPONENT = 4;\nvar NODE_TYPE_FUNCTION_COMPONENT = 5;\n\nvar SHORT_TAGS = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    command: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuitem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n};\nvar USE_DOM_STRINGS = isTrident || isEdge;\nfunction TagNode(tag) {\n    this.type = NODE_TYPE_TAG;\n    this._tag = tag;\n    this._domNode = null;\n    this._key = null;\n    this._ns = null;\n    this._attrs = null;\n    this._children = null;\n    this._escapeChildren = true;\n    this._ctx = emptyObj;\n    this._hasListeners = false;\n}\n\nTagNode.prototype = {\n    getDomNode: function () {\n        return this._domNode;\n    },\n    key: function (key) {\n        this._key = key;\n        return this;\n    },\n    ns: function (ns) {\n        this._ns = ns;\n        return this;\n    },\n    attrs: function (attrs) {\n        this._attrs = attrs;\n\n        if (IS_DEBUG) {\n            checkAttrs(attrs);\n        }\n\n        return this;\n    },\n    children: function (children) {\n        if (IS_DEBUG) {\n            if (this._children !== null) {\n                consoleWrapper.warn('You\\'re trying to set children or html more than once or pass both children and html.');\n            }\n        }\n\n        this._children = processChildren(children);\n        return this;\n    },\n    ctx: function (ctx) {\n        if (ctx !== emptyObj) {\n            this._ctx = ctx;\n\n            var children = this._children;\n\n            if (children && typeof children !== 'string') {\n                var len = children.length;\n                var i = 0;\n\n                while (i < len) {\n                    children[i++].ctx(ctx);\n                }\n            }\n        }\n\n        return this;\n    },\n    html: function (html) {\n        if (IS_DEBUG) {\n            if (this._children !== null) {\n                consoleWrapper.warn('You\\'re trying to set children or html more than once or pass both children and html.');\n            }\n        }\n\n        this._children = html;\n        this._escapeChildren = false;\n        return this;\n    },\n    renderToDom: function (parentNs) {\n        if (IS_DEBUG) {\n            checkReuse(this, this._tag);\n        }\n\n        var ns = this._ns || parentNs,\n            children = this._children;\n\n        if (USE_DOM_STRINGS && children && typeof children !== 'string') {\n            var _domNode = createElementByHtml(this.renderToString(), this._tag, ns);\n            this.adoptDom([_domNode], 0);\n            return _domNode;\n        }\n\n        var domNode = this._domNode = createElement(this._tag, ns),\n            attrs = this._attrs;\n\n        if (children) {\n            if (typeof children === 'string') {\n                this._escapeChildren ? domNode.textContent = children : domNode.innerHTML = children;\n            } else {\n                var i = 0;\n                var len = children.length;\n\n                while (i < len) {\n                    domNode.appendChild(children[i++].renderToDom(ns));\n                }\n            }\n        }\n\n        if (attrs) {\n            var name = void 0,\n                value = void 0;\n            for (name in attrs) {\n                if ((value = attrs[name]) != null) {\n                    if (ATTRS_TO_EVENTS[name]) {\n                        addListener(domNode, ATTRS_TO_EVENTS[name], value);\n                        this._hasListeners = true;\n                    } else {\n                        domAttrs(name).set(domNode, name, value);\n                    }\n                }\n            }\n        }\n\n        return domNode;\n    },\n    renderToString: function () {\n        var tag = this._tag;\n\n        if (tag === '!') {\n            return '<!---->';\n        }\n\n        var ns = this._ns,\n            attrs = this._attrs;\n        var children = this._children,\n            res = '<' + tag;\n\n        if (ns) {\n            res += ' xmlns=\"' + ns + '\"';\n        }\n\n        if (attrs) {\n            var name = void 0,\n                value = void 0,\n                attrHtml = void 0;\n            for (name in attrs) {\n                value = attrs[name];\n\n                if (value != null) {\n                    if (name === 'value') {\n                        switch (tag) {\n                            case 'textarea':\n                                children = value;\n                                continue;\n\n                            case 'select':\n                                this.ctx({ value: value, multiple: attrs.multiple });\n                                continue;\n\n                            case 'option':\n                                if (this._ctx.multiple ? isInArray(this._ctx.value, value) : this._ctx.value === value) {\n                                    res += ' ' + domAttrs('selected').toString('selected', true);\n                                }\n                        }\n                    }\n\n                    if (!ATTRS_TO_EVENTS[name] && (attrHtml = domAttrs(name).toString(name, value))) {\n                        res += ' ' + attrHtml;\n                    }\n                }\n            }\n        }\n\n        if (SHORT_TAGS[tag]) {\n            res += '/>';\n        } else {\n            res += '>';\n\n            if (children) {\n                if (typeof children === 'string') {\n                    res += this._escapeChildren ? escapeHtml(children) : children;\n                } else {\n                    var i = 0;\n                    var len = children.length;\n\n                    while (i < len) {\n                        res += children[i++].renderToString();\n                    }\n                }\n            }\n\n            res += '</' + tag + '>';\n        }\n\n        return res;\n    },\n    adoptDom: function (domNodes, domIdx) {\n        if (IS_DEBUG) {\n            checkReuse(this, this._tag);\n        }\n\n        var domNode = this._domNode = domNodes[domIdx],\n            attrs = this._attrs,\n            children = this._children;\n\n        if (attrs) {\n            var name = void 0,\n                value = void 0;\n            for (name in attrs) {\n                if ((value = attrs[name]) != null && ATTRS_TO_EVENTS[name]) {\n                    addListener(domNode, ATTRS_TO_EVENTS[name], value);\n                    this._hasListeners = true;\n                }\n            }\n        }\n\n        if (children && typeof children !== 'string') {\n            var i = 0;\n            var len = children.length;\n\n            if (len) {\n                var domChildren = domNode.childNodes;\n                var domChildIdx = 0;\n\n                while (i < len) {\n                    domChildIdx = children[i++].adoptDom(domChildren, domChildIdx);\n                }\n            }\n        }\n\n        return domIdx + 1;\n    },\n    mount: function () {\n        var children = this._children;\n\n        if (children && typeof children !== 'string') {\n            var i = 0;\n            var len = children.length;\n\n            while (i < len) {\n                children[i++].mount();\n            }\n        }\n    },\n    unmount: function () {\n        var children = this._children;\n\n        if (children && typeof children !== 'string') {\n            var i = 0;\n            var len = children.length;\n\n            while (i < len) {\n                children[i++].unmount();\n            }\n        }\n\n        if (this._hasListeners) {\n            removeListeners(this._domNode);\n            this._hasListeners = false;\n        }\n\n        this._domNode = null;\n    },\n    patch: function (node) {\n        if (this === node) {\n            return;\n        }\n\n        switch (node.type) {\n            case NODE_TYPE_TAG:\n                if (this._tag !== node._tag || this._ns !== node._ns) {\n                    patchOps.replace(this, node);\n                } else {\n                    node._domNode = this._domNode;\n                    this._patchChildren(node);\n                    this._patchAttrs(node);\n                }\n                break;\n\n            case NODE_TYPE_COMPONENT:\n                var instance = node._getInstance();\n\n                this.patch(instance.getRootNode());\n                instance.mount();\n                break;\n\n            case NODE_TYPE_FUNCTION_COMPONENT:\n                this.patch(node._getRootNode());\n                break;\n\n            default:\n                patchOps.replace(this, node);\n        }\n    },\n    _patchChildren: function (node) {\n        var childrenA = this._children,\n            childrenB = node._children;\n\n        if (childrenA === childrenB) {\n            return;\n        }\n\n        var isChildrenAText = typeof childrenA === 'string',\n            isChildrenBText = typeof childrenB === 'string';\n\n        if (isChildrenBText) {\n            if (isChildrenAText) {\n                patchOps.updateText(this, childrenB, node._escapeChildren);\n                return;\n            }\n\n            childrenA && childrenA.length && patchOps.removeChildren(this);\n            childrenB && patchOps.updateText(this, childrenB, node._escapeChildren);\n\n            return;\n        }\n\n        if (!childrenB || !childrenB.length) {\n            if (childrenA) {\n                isChildrenAText ? patchOps.removeText(this) : childrenA.length && patchOps.removeChildren(this);\n            }\n\n            return;\n        }\n\n        if (isChildrenAText && childrenA) {\n            patchOps.removeText(this);\n        }\n\n        if (isChildrenAText || !childrenA || !childrenA.length) {\n            var childrenBLen = childrenB.length;\n            var iB = 0;\n\n            while (iB < childrenBLen) {\n                patchOps.appendChild(node, childrenB[iB++]);\n            }\n\n            return;\n        }\n\n        patchChildren(this, node);\n    },\n    _patchAttrs: function (node) {\n        var attrsA = this._attrs,\n            attrsB = node._attrs;\n\n        if (attrsA === attrsB) {\n            return;\n        }\n\n        var attrName = void 0,\n            attrAVal = void 0,\n            attrBVal = void 0,\n            isAttrAValArray = void 0,\n            isAttrBValArray = void 0;\n\n        if (attrsB) {\n            for (attrName in attrsB) {\n                attrBVal = attrsB[attrName];\n                if (!attrsA || (attrAVal = attrsA[attrName]) == null) {\n                    if (attrBVal != null) {\n                        patchOps.updateAttr(this, attrName, attrBVal);\n                    }\n                } else if (attrBVal == null) {\n                    patchOps.removeAttr(this, attrName);\n                } else if (typeof attrBVal === 'object' && typeof attrAVal === 'object') {\n                    isAttrBValArray = Array.isArray(attrBVal);\n                    isAttrAValArray = Array.isArray(attrAVal);\n                    if (isAttrBValArray || isAttrAValArray) {\n                        if (isAttrBValArray && isAttrAValArray) {\n                            this._patchAttrArr(attrName, attrAVal, attrBVal);\n                        } else {\n                            patchOps.updateAttr(this, attrName, attrBVal);\n                        }\n                    } else {\n                        this._patchAttrObj(attrName, attrAVal, attrBVal);\n                    }\n                } else if (attrAVal !== attrBVal) {\n                    patchOps.updateAttr(this, attrName, attrBVal);\n                }\n            }\n        }\n\n        if (attrsA) {\n            for (attrName in attrsA) {\n                if ((!attrsB || !(attrName in attrsB)) && (attrAVal = attrsA[attrName]) != null) {\n                    patchOps.removeAttr(this, attrName);\n                }\n            }\n        }\n    },\n    _patchAttrArr: function (attrName, arrA, arrB) {\n        if (arrA === arrB) {\n            return;\n        }\n\n        var lenA = arrA.length;\n        var hasDiff = false;\n\n        if (lenA === arrB.length) {\n            var i = 0;\n            while (!hasDiff && i < lenA) {\n                if (arrA[i] != arrB[i]) {\n                    hasDiff = true;\n                }\n                ++i;\n            }\n        } else {\n            hasDiff = true;\n        }\n\n        hasDiff && patchOps.updateAttr(this, attrName, arrB);\n    },\n    _patchAttrObj: function (attrName, objA, objB) {\n        if (objA === objB) {\n            return;\n        }\n\n        var hasDiff = false,\n            diffObj = {};\n\n        for (var i in objB) {\n            if (objA[i] != objB[i]) {\n                hasDiff = true;\n                diffObj[i] = objB[i];\n            }\n        }\n\n        for (var _i in objA) {\n            if (objA[_i] != null && !(_i in objB)) {\n                hasDiff = true;\n                diffObj[_i] = null;\n            }\n        }\n\n        hasDiff && patchOps.updateAttr(this, attrName, diffObj);\n    }\n};\n\nfunction processChildren(children) {\n    if (children == null) {\n        return null;\n    }\n\n    var typeOfChildren = typeof children;\n\n    if (typeOfChildren === 'object') {\n        var res = Array.isArray(children) ? children : [children];\n\n        if (IS_DEBUG) {\n            checkChildren(res);\n        }\n\n        return res;\n    }\n\n    return typeOfChildren === 'string' ? children : children.toString();\n}\n\nfunction checkAttrs(attrs) {\n    for (var name in attrs) {\n        if (name.substr(0, 2) === 'on' && !ATTRS_TO_EVENTS[name]) {\n            consoleWrapper.error('You\\'re trying to add unsupported event listener \"' + name + '\".');\n        }\n    }\n}\n\nfunction ComponentNode(component) {\n    this.type = NODE_TYPE_COMPONENT;\n    this._component = component;\n    this._key = null;\n    this._attrs = null;\n    this._instance = null;\n    this._children = null;\n    this._ctx = emptyObj;\n}\n\nComponentNode.prototype = {\n    getDomNode: function () {\n        return this._instance && this._instance.getDomNode();\n    },\n    key: function (key) {\n        this._key = key;\n        return this;\n    },\n    attrs: function (attrs) {\n        this._attrs = attrs;\n        return this;\n    },\n    children: function (children) {\n        this._children = children;\n        return this;\n    },\n    ctx: function (ctx) {\n        this._ctx = ctx;\n        return this;\n    },\n    renderToDom: function (parentNs) {\n        if (IS_DEBUG) {\n            checkReuse(this, this._component.name || 'Anonymous');\n        }\n\n        return this._getInstance().renderToDom(parentNs);\n    },\n    renderToString: function () {\n        return this._getInstance().renderToString();\n    },\n    adoptDom: function (domNode, domIdx) {\n        if (IS_DEBUG) {\n            checkReuse(this, this._component.name || 'Anonymous');\n        }\n\n        return this._getInstance().adoptDom(domNode, domIdx);\n    },\n    mount: function () {\n        this._instance.getRootNode().mount();\n        this._instance.mount();\n    },\n    unmount: function () {\n        if (this._instance) {\n            this._instance.getRootNode().unmount();\n            this._instance.unmount();\n            this._instance = null;\n        }\n    },\n    patch: function (node) {\n        if (this === node) {\n            return;\n        }\n\n        var instance = this._getInstance();\n\n        if (this.type === node.type) {\n            if (this._component === node._component) {\n                instance.patch(node._attrs, node._children, node._ctx);\n                node._instance = instance;\n            } else {\n                instance.unmount();\n                var newInstance = node._getInstance();\n                instance.getRootNode().patch(newInstance.getRootNode());\n                newInstance.mount();\n            }\n        } else {\n            instance.unmount();\n            instance.getRootNode().patch(node);\n        }\n    },\n    _getInstance: function () {\n        return this._instance || (this._instance = new this._component(this._attrs, this._children, this._ctx));\n    }\n};\n\nfunction FunctionComponentNode(component) {\n    this.type = NODE_TYPE_FUNCTION_COMPONENT;\n    this._component = component;\n    this._key = null;\n    this._attrs = emptyObj;\n    this._rootNode = null;\n    this._children = null;\n    this._ctx = emptyObj;\n}\n\nFunctionComponentNode.prototype = {\n    getDomNode: function () {\n        return this._rootNode && this._rootNode.getDomNode();\n    },\n    key: function (key) {\n        this._key = key;\n        return this;\n    },\n    attrs: function (attrs) {\n        this._attrs = attrs;\n        return this;\n    },\n    children: function (children) {\n        this._children = children;\n        return this;\n    },\n    ctx: function (ctx) {\n        this._ctx = ctx;\n        return this;\n    },\n    renderToDom: function (parentNs) {\n        if (IS_DEBUG) {\n            checkReuse(this, this._component.name || 'Anonymous');\n        }\n\n        return this._getRootNode().renderToDom(parentNs);\n    },\n    renderToString: function () {\n        return this._getRootNode().renderToString();\n    },\n    adoptDom: function (domNode, domIdx) {\n        if (IS_DEBUG) {\n            checkReuse(this, this._component.name || 'Anonymous');\n        }\n\n        return this._getRootNode().adoptDom(domNode, domIdx);\n    },\n    mount: function () {\n        this._getRootNode().mount();\n    },\n    unmount: function () {\n        if (this._rootNode) {\n            this._rootNode.unmount();\n            this._rootNode = null;\n        }\n    },\n    patch: function (node) {\n        if (this === node) {\n            return;\n        }\n\n        this._getRootNode().patch(this.type === node.type ? node._getRootNode() : node);\n    },\n    _getRootNode: function () {\n        if (this._rootNode) {\n            return this._rootNode;\n        }\n\n        var rootNode = this._component(this._attrs, this._children, this._ctx) || createNode('!');\n\n        if (IS_DEBUG) {\n            if (typeof rootNode !== 'object' || Array.isArray(rootNode)) {\n                console.error('Function component must return a single node object on the top level');\n            }\n        }\n\n        rootNode.ctx(this._ctx);\n\n        return this._rootNode = rootNode;\n    }\n};\n\nfunction FragmentNode() {\n    this.type = NODE_TYPE_FRAGMENT;\n    this._domNode = null;\n    this._key = null;\n    this._children = null;\n    this._ctx = emptyObj;\n}\n\nFragmentNode.prototype = {\n    getDomNode: function () {\n        return this._domNode;\n    },\n    key: function (key) {\n        this._key = key;\n        return this;\n    },\n    children: function (children) {\n        if (IS_DEBUG) {\n            if (this._children !== null) {\n                consoleWrapper.warn('You\\'re trying to set children to fragment more than once.');\n            }\n        }\n\n        this._children = processChildren$1(children);\n        return this;\n    },\n    ctx: function (ctx) {\n        if (ctx !== emptyObj) {\n            this._ctx = ctx;\n\n            var children = this._children;\n\n            if (children) {\n                var len = children.length;\n                var i = 0;\n\n                while (i < len) {\n                    children[i++].ctx(ctx);\n                }\n            }\n        }\n\n        return this;\n    },\n    renderToDom: function (parentNs) {\n        if (IS_DEBUG) {\n            checkReuse(this, 'fragment');\n        }\n\n        var children = this._children,\n            domNode = [createElement('!'), createElement('!')],\n            domFragment = document.createDocumentFragment();\n\n        domFragment.appendChild(domNode[0]);\n\n        if (children) {\n            var len = children.length;\n            var i = 0;\n\n            while (i < len) {\n                domFragment.appendChild(children[i++].renderToDom(parentNs));\n            }\n        }\n\n        domFragment.appendChild(domNode[1]);\n\n        this._domNode = domNode;\n\n        return domFragment;\n    },\n    renderToString: function () {\n        var children = this._children;\n        var res = '<!---->';\n\n        if (children) {\n            var i = children.length - 1;\n\n            while (i >= 0) {\n                res = children[i--].renderToString() + res;\n            }\n        }\n\n        return '<!---->' + res;\n    },\n    adoptDom: function (domNodes, domIdx) {\n        if (IS_DEBUG) {\n            checkReuse(this, 'fragment');\n        }\n\n        var domNode = [domNodes[domIdx++]],\n            children = this._children;\n\n        if (children) {\n            var len = children.length;\n            var i = 0;\n\n            while (i < len) {\n                domIdx = children[i++].adoptDom(domNodes, domIdx);\n            }\n        }\n\n        domNode.push(domNodes[domIdx]);\n\n        this._domNode = domNode;\n\n        return domIdx + 1;\n    },\n    mount: function () {\n        var children = this._children;\n\n        if (children) {\n            var i = 0;\n            var len = children.length;\n\n            while (i < len) {\n                children[i++].mount();\n            }\n        }\n    },\n    unmount: function () {\n        var children = this._children;\n\n        if (children) {\n            var len = children.length;\n            var i = 0;\n\n            while (i < len) {\n                children[i++].unmount();\n            }\n        }\n    },\n    patch: function (node) {\n        if (this === node) {\n            return;\n        }\n\n        switch (node.type) {\n            case NODE_TYPE_FRAGMENT:\n                node._domNode = this._domNode;\n                this._patchChildren(node);\n                break;\n\n            case NODE_TYPE_COMPONENT:\n                var instance = node._getInstance();\n\n                this.patch(instance.getRootNode());\n                instance.mount();\n                break;\n\n            case NODE_TYPE_FUNCTION_COMPONENT:\n                this.patch(node._getRootNode());\n                break;\n\n            default:\n                patchOps.replace(this, node);\n        }\n    },\n    _patchChildren: function (node) {\n        var childrenA = this._children,\n            childrenB = node._children;\n\n        if (childrenA === childrenB) {\n            return;\n        }\n\n        if (!childrenB || !childrenB.length) {\n            if (childrenA && childrenA.length) {\n                patchOps.removeChildren(this);\n            }\n\n            return;\n        }\n\n        if (!childrenA || !childrenA.length) {\n            var childrenBLen = childrenB.length;\n            var iB = 0;\n\n            while (iB < childrenBLen) {\n                patchOps.appendChild(node, childrenB[iB++]);\n            }\n\n            return;\n        }\n\n        patchChildren(this, node);\n    }\n};\n\nfunction processChildren$1(children) {\n    if (children == null) {\n        return null;\n    }\n\n    var res = Array.isArray(children) ? children : [children];\n\n    if (IS_DEBUG) {\n        checkChildren(res);\n    }\n\n    return res;\n}\n\nvar raf = typeof window !== 'undefined' && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame) || function (callback) {\n    setTimeout(callback, 1000 / 60);\n};\n\nvar batch = [];\n\nfunction applyBatch() {\n    var i = 0;\n\n    while (i < batch.length) {\n        batch[i++]();\n    }\n\n    batch = [];\n}\n\nvar rafBatch = (function (fn) {\n    batch.push(fn) === 1 && raf(applyBatch);\n});\n\nfunction Emitter() {\n    this._listeners = {};\n}\n\nEmitter.prototype = {\n    on: function (event, fn) {\n        var fnCtx = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n        (this._listeners[event] || (this._listeners[event] = [])).push({ fn: fn, fnCtx: fnCtx });\n\n        return this;\n    },\n    off: function (event, fn) {\n        var fnCtx = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n        var eventListeners = this._listeners[event];\n\n        if (eventListeners) {\n            var i = 0,\n                eventListener = void 0;\n\n            while (i < eventListeners.length) {\n                eventListener = eventListeners[i];\n                if (eventListener.fn === fn && eventListener.fnCtx === fnCtx) {\n                    eventListeners.splice(i, 1);\n                    break;\n                }\n\n                i++;\n            }\n        }\n\n        return this;\n    },\n    emit: function (event) {\n        var eventListeners = this._listeners[event];\n\n        if (eventListeners) {\n            var i = 0;\n\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            while (i < eventListeners.length) {\n                var _eventListeners = eventListeners[i++];\n                var fn = _eventListeners.fn;\n                var fnCtx = _eventListeners.fnCtx;\n\n                fn.call.apply(fn, [fnCtx].concat(args));\n            }\n        }\n\n        return this;\n    }\n};\n\nfunction TopNode(childNode, ns) {\n    this.type = NODE_TYPE_TOP;\n    this._childNode = childNode;\n    this._ns = ns;\n}\n\nTopNode.prototype = {\n    getDomNode: function () {\n        return this._childNode.getDomNode();\n    },\n    renderToDom: function () {\n        return this._childNode.renderToDom(this._ns);\n    },\n    adoptDom: function (domNode) {\n        this._childNode.adoptDom(domNode, 0);\n    },\n    patch: function (node) {\n        this._childNode.patch(node._childNode);\n    },\n    mount: function () {\n        this._childNode.mount();\n    },\n    unmount: function () {\n        this._childNode.unmount();\n    }\n};\n\nvar mountedNodes = {};\nvar counter$1 = 0;\n\nfunction mount(domNode, node, cb, cbCtx, syncMode) {\n    var domNodeId = getDomNodeId(domNode),\n        mounted = mountedNodes[domNodeId],\n        mountId = void 0;\n\n    if (mounted && mounted.tree) {\n        mountId = ++mounted.id;\n        var patchFn = function () {\n            if (mountedNodes[domNodeId] && mountedNodes[domNodeId].id === mountId) {\n                var prevTree = mounted.tree,\n                    newTree = new TopNode(node, prevTree._ns);\n\n                prevTree.patch(newTree);\n                mounted.tree = newTree;\n\n                callCb(cb, cbCtx);\n                if (IS_DEBUG) {\n                    hook.emit('replace', prevTree, newTree);\n                }\n            }\n        };\n\n        syncMode ? patchFn() : rafBatch(patchFn);\n    } else {\n        mounted = mountedNodes[domNodeId] = { tree: null, id: mountId = ++counter$1 };\n\n        if (domNode.children.length) {\n            var tree = mounted.tree = new TopNode(node, getNs(domNode));\n\n            tree.adoptDom(collectTopDomChildren(domNode));\n            tree.mount();\n            callCb(cb, cbCtx);\n            if (IS_DEBUG) {\n                hook.emit('mount', tree);\n            }\n        } else {\n            var renderFn = function () {\n                var mounted = mountedNodes[domNodeId];\n\n                if (mounted && mounted.id === mountId) {\n                    var _tree = mounted.tree = new TopNode(node, getNs(domNode));\n\n                    domOps.append(domNode, _tree.renderToDom());\n                    _tree.mount();\n                    callCb(cb, cbCtx);\n                    if (IS_DEBUG) {\n                        hook.emit('mount', _tree);\n                    }\n                }\n            };\n\n            syncMode ? renderFn() : rafBatch(renderFn);\n        }\n    }\n}\n\nfunction unmount(domNode, cb, cbCtx, syncMode) {\n    var domNodeId = getDomNodeId(domNode);\n    var mounted = mountedNodes[domNodeId];\n\n    if (mounted) {\n        (function () {\n            var mountId = ++mounted.id,\n                unmountFn = function () {\n                mounted = mountedNodes[domNodeId];\n                if (mounted && mounted.id === mountId) {\n                    delete mountedNodes[domNodeId];\n                    var tree = mounted.tree;\n\n                    if (tree) {\n                        var treeDomNode = tree.getDomNode();\n\n                        tree.unmount();\n                        domOps.remove(treeDomNode);\n                    }\n\n                    callCb(cb, cbCtx);\n                    if (IS_DEBUG) {\n                        tree && hook.emit('unmount', tree);\n                    }\n                }\n            };\n\n            mounted.tree ? syncMode ? unmountFn() : rafBatch(unmountFn) : syncMode || callCb(cb, cbCtx);\n        })();\n    } else if (!syncMode) {\n        callCb(cb, cbCtx);\n    }\n}\n\nfunction callCb(cb, cbCtx) {\n    cb && cb.call(cbCtx || this);\n}\n\nfunction collectTopDomChildren(node) {\n    var children = node.childNodes,\n        len = children.length,\n        res = [];\n    var i = 0,\n        nodeType = void 0;\n\n    while (i < len) {\n        nodeType = children[i].nodeType;\n\n        if (nodeType === Node.ELEMENT_NODE || nodeType === Node.COMMENT_NODE) {\n            res.push(children[i]);\n        }\n\n        i++;\n    }\n\n    return res;\n}\n\nfunction mountToDom(domNode, tree, cb, cbCtx) {\n    mount(domNode, tree, cb, cbCtx, false);\n}\n\nfunction mountToDomSync(domNode, tree) {\n    mount(domNode, tree, null, null, true);\n}\n\nfunction unmountFromDom(domNode, cb, cbCtx) {\n    unmount(domNode, cb, cbCtx, false);\n}\n\nfunction unmountFromDomSync(domNode) {\n    unmount(domNode, null, null, true);\n}\n\nfunction getMountedRootNodes() {\n    var res = [];\n    var mountedNode = void 0;\n\n    for (var id in mountedNodes) {\n        mountedNode = mountedNodes[id];\n        if (mountedNode.tree) {\n            res.push(mountedNode.tree);\n        }\n    }\n\n    return res;\n}\n\nvar hook = new Emitter();\n\nhook.getRootNodes = getMountedRootNodes;\n\nif (IS_DEBUG) {\n    if (typeof window !== 'undefined') {\n        window['__vidom__hook__'] = hook;\n    }\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction mountComponent() {\n    this._isMounted = true;\n    this.onMount(this._attrs);\n}\n\nfunction unmountComponent() {\n    this._isMounted = false;\n    this._domRefs = null;\n    this.onUnmount();\n}\n\nfunction patchComponent(attrs, children, ctx) {\n    attrs = this._buildAttrs(attrs);\n\n    var prevRootNode = this._rootNode,\n        prevAttrs = this._attrs,\n        prevChildren = this._children;\n\n    if (prevAttrs !== attrs || prevChildren !== children) {\n        this._attrs = attrs;\n        if (this.isMounted()) {\n            var isUpdating = this._isUpdating;\n            this._isUpdating = true;\n            this.onAttrsReceive(attrs, prevAttrs, children, prevChildren);\n            this._isUpdating = isUpdating;\n        }\n    }\n\n    this._children = children;\n    this._ctx = ctx;\n\n    if (this._isUpdating) {\n        return;\n    }\n\n    var shouldUpdate = this.shouldUpdate(attrs, prevAttrs, children, prevChildren);\n\n    if (IS_DEBUG) {\n        var shouldUpdateResType = typeof shouldUpdate;\n        if (shouldUpdateResType !== 'boolean') {\n            consoleWrapper.warn('Component#shouldUpdate() should return boolean instead of ' + shouldUpdateResType);\n        }\n    }\n\n    if (shouldUpdate) {\n        this._rootNode = this.render();\n        prevRootNode.patch(this._rootNode);\n        this.isMounted() && this.onUpdate(attrs, prevAttrs, children, prevChildren);\n    }\n}\n\nfunction shouldComponentUpdate() {\n    return true;\n}\n\nfunction renderComponentToDom(parentNs) {\n    return this._rootNode.renderToDom(parentNs);\n}\n\nfunction renderComponentToString() {\n    return this._rootNode.renderToString();\n}\n\nfunction adoptComponentDom(domNode, domIdx) {\n    return this._rootNode.adoptDom(domNode, domIdx);\n}\n\nfunction getComponentDomNode() {\n    return this._rootNode.getDomNode();\n}\n\nfunction getComponentAttrs() {\n    return this._attrs;\n}\n\nfunction requestChildContext() {\n    return emptyObj;\n}\n\nfunction requestInitialComponentState() {\n    return emptyObj;\n}\n\nfunction setComponentState(state) {\n    this._prevState = this._state;\n    this._state = _extends({}, this._state, state);\n\n    this.update(updateComponentPrevState);\n}\n\nfunction updateComponentPrevState() {\n    this._prevState = this._state;\n}\n\nfunction getComponentState() {\n    return this._state;\n}\n\nfunction getComponentPrevState() {\n    return this._prevState;\n}\n\nfunction renderComponent() {\n    this._domRefs = {};\n\n    var rootNode = this.onRender(this._attrs, this._children) || createNode('!');\n\n    if (IS_DEBUG) {\n        if (typeof rootNode !== 'object' || Array.isArray(rootNode)) {\n            consoleWrapper.error('Component#onRender must return a single node object on the top level');\n        }\n    }\n\n    var childCtx = this.onChildContextRequest(this._attrs);\n\n    rootNode.ctx(childCtx === emptyObj ? this._ctx : this._ctx === emptyObj ? childCtx : _extends({}, this._ctx, childCtx));\n\n    return rootNode;\n}\n\nfunction updateComponent(cb, cbCtx) {\n    var _this = this;\n\n    if (this._isUpdating) {\n        cb && rafBatch(function () {\n            return cb.call(cbCtx || _this);\n        });\n    } else {\n        this._isUpdating = true;\n        rafBatch(function () {\n            if (_this.isMounted()) {\n                _this._isUpdating = false;\n                var prevRootNode = _this._rootNode;\n                _this.patch(_this._attrs, _this._children, _this._ctx);\n                cb && cb.call(cbCtx || _this);\n                if (IS_DEBUG) {\n                    hook.emit('replace', prevRootNode, _this._rootNode);\n                }\n            }\n        });\n    }\n}\n\nfunction getComponentRootNode() {\n    return this._rootNode;\n}\n\nfunction isComponentMounted() {\n    return this._isMounted;\n}\n\nfunction setComponentDomRef(ref, node) {\n    return this._domRefs[ref] = node;\n}\n\nfunction getComponentDomRef(ref) {\n    return this._domRefs[ref] ? this._domRefs[ref].getDomNode() : null;\n}\n\nfunction getComponentContext() {\n    return this._ctx;\n}\n\nfunction getComponentDefaultAttrs() {\n    return emptyObj;\n}\n\nfunction buildComponentAttrs(attrs) {\n    if (this._attrs && attrs === this._attrs) {\n        return attrs;\n    }\n\n    var cons = this.constructor,\n        defaultAttrs = cons._defaultAttrs || (cons._defaultAttrs = cons.getDefaultAttrs());\n\n    if (!attrs) {\n        return defaultAttrs;\n    }\n\n    if (defaultAttrs === emptyObj) {\n        return attrs;\n    }\n\n    var res = {};\n\n    for (var i in defaultAttrs) {\n        res[i] = defaultAttrs[i];\n    }\n\n    for (var _i in attrs) {\n        res[_i] = attrs[_i];\n    }\n\n    return res;\n}\n\nfunction createComponent(props, staticProps) {\n    var res = function (attrs, children, ctx) {\n        this._attrs = this._buildAttrs(attrs);\n        this._children = children;\n        this._ctx = ctx;\n        this._domRefs = null;\n        this._isMounted = false;\n        this._isUpdating = false;\n        this._state = this.onInitialStateRequest(this._attrs, children);\n        this._prevState = this._state;\n        this.onInit(this._attrs, children);\n        this._rootNode = this.render();\n    },\n        ptp = {\n        constructor: res,\n        onInitialStateRequest: requestInitialComponentState,\n        onInit: noOp,\n        mount: mountComponent,\n        unmount: unmountComponent,\n        onMount: noOp,\n        onUnmount: noOp,\n        onAttrsReceive: noOp,\n        shouldUpdate: shouldComponentUpdate,\n        onUpdate: noOp,\n        isMounted: isComponentMounted,\n        getState: getComponentState,\n        getPrevState: getComponentPrevState,\n        setState: setComponentState,\n        renderToDom: renderComponentToDom,\n        renderToString: renderComponentToString,\n        adoptDom: adoptComponentDom,\n        getDomNode: getComponentDomNode,\n        getRootNode: getComponentRootNode,\n        render: renderComponent,\n        onRender: noOp,\n        update: updateComponent,\n        patch: patchComponent,\n        getDomRef: getComponentDomRef,\n        setDomRef: setComponentDomRef,\n        getAttrs: getComponentAttrs,\n        onChildContextRequest: requestChildContext,\n        getContext: getComponentContext,\n        _buildAttrs: buildComponentAttrs\n    };\n\n    for (var i in props) {\n        ptp[i] = props[i];\n    }\n\n    res.prototype = ptp;\n\n    res.getDefaultAttrs = getComponentDefaultAttrs;\n\n    for (var _i2 in staticProps) {\n        res[_i2] = staticProps[_i2];\n    }\n\n    res['__vidom__component__'] = true;\n\n    return res;\n}\n\nvar Input = createComponent({\n    onInit: function () {\n        var _this = this;\n\n        this.onInput = function (e) {\n            var attrs = _this.getAttrs();\n\n            attrs.onInput && attrs.onInput(e);\n            attrs.onChange && attrs.onChange(e);\n\n            applyBatch();\n\n            if (_this.isMounted()) {\n                // attrs could be changed during applyBatch()\n                attrs = _this.getAttrs();\n                var control = _this.getDomRef('control');\n                if (typeof attrs.value !== 'undefined' && control.value !== attrs.value) {\n                    control.value = attrs.value;\n                }\n            }\n        };\n\n        this.onClick = function (e) {\n            var attrs = _this.getAttrs();\n\n            attrs.onClick && attrs.onClick(e);\n            attrs.onChange && attrs.onChange(e);\n\n            applyBatch();\n\n            if (_this.isMounted()) {\n                // attrs could be changed during applyBatch()\n                attrs = _this.getAttrs();\n                var control = _this.getDomRef('control');\n                if (typeof attrs.checked !== 'undefined' && control.checked !== attrs.checked) {\n                    control.checked = attrs.checked;\n                }\n            }\n        };\n    },\n    onRender: function (attrs) {\n        var controlAttrs = void 0;\n\n        if (attrs.type === 'file') {\n            controlAttrs = attrs;\n        } else {\n            controlAttrs = _extends({}, attrs, { onChange: null });\n\n            if (attrs.type === 'checkbox' || attrs.type === 'radio') {\n                controlAttrs.onClick = this.onClick;\n            } else {\n                controlAttrs.onInput = this.onInput;\n            }\n        }\n\n        return this.setDomRef('control', new TagNode('input').attrs(controlAttrs));\n    }\n});\n\nvar Textarea = createComponent({\n    onInit: function () {\n        var _this = this;\n\n        this.onInput = function (e) {\n            var attrs = _this.getAttrs();\n\n            attrs.onInput && attrs.onInput(e);\n            attrs.onChange && attrs.onChange(e);\n\n            applyBatch();\n\n            if (_this.isMounted()) {\n                // attrs could be changed during applyBatch()\n                attrs = _this.getAttrs();\n                var control = _this.getDomRef('control');\n                if (typeof attrs.value !== 'undefined' && control.value !== attrs.value) {\n                    control.value = attrs.value;\n                }\n            }\n        };\n    },\n    onRender: function (attrs) {\n        var controlAttrs = _extends({}, attrs, {\n            onInput: this.onInput,\n            onChange: null\n        });\n\n        return this.setDomRef('control', new TagNode('textarea').attrs(controlAttrs));\n    }\n});\n\nvar Select = createComponent({\n    onInit: function () {\n        var _this = this;\n\n        this.onChange = function (e) {\n            var attrs = _this.getAttrs();\n\n            attrs.onChange && attrs.onChange(e);\n\n            applyBatch();\n\n            if (_this.isMounted()) {\n                // attrs could be changed during applyBatch()\n                attrs = _this.getAttrs();\n                var control = _this.getDomRef('control');\n                if (typeof attrs.value !== 'undefined' && control.value !== attrs.value) {\n                    control.value = attrs.value;\n                }\n            }\n        };\n    },\n    onRender: function (attrs, children) {\n        var controlAttrs = _extends({}, attrs, {\n            onChange: this.onChange\n        });\n\n        return this.setDomRef('control', new TagNode('select').attrs(controlAttrs).children(children));\n    }\n});\n\nvar WRAPPER_COMPONENTS = {\n    input: Input,\n    textarea: Textarea,\n    select: Select\n};\n\nfunction createNode (type) {\n    switch (typeof type) {\n        case 'string':\n            return type === 'fragment' ? new FragmentNode() : WRAPPER_COMPONENTS[type] ? new ComponentNode(WRAPPER_COMPONENTS[type]) : new TagNode(type);\n\n        case 'function':\n            return type.__vidom__component__ ? new ComponentNode(type) : new FunctionComponentNode(type);\n\n        default:\n            if (IS_DEBUG) {\n                consoleWrapper.error('Unsupported type of node');\n            }\n    }\n}\n\nvar renderToString = (function (tree) {\n  return tree.renderToString();\n});\n\nfunction normalizeChildren(children) {\n    if (children == null) {\n        return null;\n    }\n\n    var typeOfChildren = typeof children;\n    if (typeOfChildren !== 'object') {\n        return typeOfChildren === 'string' ? children || null : '' + children;\n    }\n\n    if (!Array.isArray(children)) {\n        return children;\n    }\n\n    if (!children.length) {\n        return null;\n    }\n\n    var res = children,\n        i = 0,\n        len = children.length,\n        allSkipped = true,\n        child = void 0,\n        isChildObject = void 0;\n\n    while (i < len) {\n        child = normalizeChildren(children[i]);\n        if (child === null) {\n            if (res !== null) {\n                if (allSkipped) {\n                    res = null;\n                } else if (res === children) {\n                    res = children.slice(0, i);\n                }\n            }\n        } else {\n            if (res === null) {\n                res = child;\n            } else if (Array.isArray(child)) {\n                res = allSkipped ? child : (res === children ? res.slice(0, i) : Array.isArray(res) ? res : [res]).concat(child);\n            } else {\n                isChildObject = typeof child === 'object';\n\n                if (isChildObject && children[i] === child) {\n                    if (res !== children) {\n                        res = join(res, child);\n                    }\n                } else {\n                    if (res === children) {\n                        if (allSkipped && isChildObject) {\n                            res = child;\n                            allSkipped = false;\n                            ++i;\n                            continue;\n                        }\n\n                        res = res.slice(0, i);\n                    }\n\n                    res = join(res, child);\n                }\n            }\n\n            allSkipped = false;\n        }\n\n        ++i;\n    }\n\n    return res;\n}\n\nfunction toNode(obj) {\n    return typeof obj === 'object' ? obj : createNode('span').children(obj);\n}\n\nfunction join(objA, objB) {\n    if (Array.isArray(objA)) {\n        objA.push(toNode(objB));\n        return objA;\n    }\n\n    return [toNode(objA), toNode(objB)];\n}\n\nfunction normalizeChildren$1 (children) {\n    var res = normalizeChildren(children);\n\n    if (res !== null && typeof res === 'object' && !Array.isArray(res)) {\n        res = [res];\n    }\n\n    return res;\n}\n\nvar Component = createComponent();\n\nif (IS_DEBUG) {\n    consoleWrapper.info('You\\'re using dev version of Vidom');\n}\n\nexports.node = createNode;\nexports.createComponent = createComponent;\nexports.renderToString = renderToString;\nexports.normalizeChildren = normalizeChildren$1;\nexports.IS_DEBUG = IS_DEBUG;\nexports.console = consoleWrapper;\nexports.Component = Component;\nexports.mountToDom = mountToDom;\nexports.mountToDomSync = mountToDomSync;\nexports.unmountFromDom = unmountFromDom;\nexports.unmountFromDomSync = unmountFromDomSync;\nexports.getMountedRootNodes = getMountedRootNodes;"]}